"""
Directional trading strategy.

This module contains the signal generation logic for the trading bot.
Customize the `generate_signal` function to implement your trading strategy.
"""

import logging
from dataclasses import dataclass
from typing import Optional, List

from bot.execution import engine

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """
    A trading signal generated by the strategy.

    Attributes:
        token_id: The conditional token to trade
        side: "BUY" or "SELL"
        price: Target price (0-1)
        size: Number of shares
        reason: Human-readable explanation for the trade
        confidence: Confidence level (0-1)
    """
    token_id: str
    side: str  # "BUY" or "SELL"
    price: float
    size: float
    reason: str
    confidence: float = 0.5


@dataclass
class MarketConfig:
    """
    Configuration for a market the bot is watching.

    Customize this to track specific markets of interest.
    """
    condition_id: str  # Market condition ID
    token_id_yes: str  # YES token ID
    token_id_no: str   # NO token ID
    name: str          # Human-readable name


# =============================================================================
# CUSTOMIZE THIS SECTION
# =============================================================================

# Markets to watch - add your markets here
# You can find token IDs on Polymarket or via the API
WATCHED_MARKETS: List[MarketConfig] = [
    # Example (replace with real IDs):
    # MarketConfig(
    #     condition_id="0x...",
    #     token_id_yes="12345...",
    #     token_id_no="67890...",
    #     name="Will X happen by Y date?"
    # ),
]


def generate_signal() -> Optional[Signal]:
    """
    Generate a trading signal based on current market conditions.

    This is the main entry point for your trading logic.
    Customize this function to implement your strategy.

    Returns:
        A Signal object if there's a trade to make, None otherwise.

    Example strategies you might implement:
    - Price threshold: Buy when price drops below X, sell when above Y
    - Mean reversion: Trade when price deviates significantly from average
    - News-based: React to external signals/events
    - Arbitrage: Compare related markets
    """

    # Skip if no markets configured
    if not WATCHED_MARKETS:
        logger.debug("No markets configured in WATCHED_MARKETS")
        return None

    # Example: Simple price threshold strategy (customize this!)
    for market in WATCHED_MARKETS:
        try:
            # Get current market price
            midpoint = engine.get_midpoint(market.token_id_yes)
            if midpoint is None:
                continue

            # Example logic (replace with your actual strategy):
            #
            # if midpoint < 0.30:
            #     return Signal(
            #         token_id=market.token_id_yes,
            #         side="BUY",
            #         price=midpoint + 0.01,  # Bid slightly above midpoint
            #         size=10,
            #         reason=f"{market.name} YES price low at {midpoint:.2f}",
            #         confidence=0.7,
            #     )
            #
            # if midpoint > 0.70:
            #     return Signal(
            #         token_id=market.token_id_yes,
            #         side="SELL",
            #         price=midpoint - 0.01,  # Ask slightly below midpoint
            #         size=10,
            #         reason=f"{market.name} YES price high at {midpoint:.2f}",
            #         confidence=0.7,
            #     )

            logger.debug(f"Market {market.name}: midpoint={midpoint:.4f}")

        except Exception as e:
            logger.warning(f"Error analyzing market {market.name}: {e}")
            continue

    # No signal generated
    return None


def validate_signal(signal: Signal) -> bool:
    """
    Validate a signal before execution.

    Add any additional validation logic here.
    """
    if signal.confidence < 0.5:
        logger.info(f"Signal rejected: low confidence ({signal.confidence})")
        return False

    if signal.size <= 0:
        logger.warning(f"Signal rejected: invalid size ({signal.size})")
        return False

    if not (0 < signal.price < 1):
        logger.warning(f"Signal rejected: invalid price ({signal.price})")
        return False

    return True


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_market_summary() -> dict:
    """Get a summary of watched markets and their current prices."""
    summary = {}
    for market in WATCHED_MARKETS:
        try:
            midpoint = engine.get_midpoint(market.token_id_yes)
            summary[market.name] = {
                "condition_id": market.condition_id,
                "token_id_yes": market.token_id_yes,
                "token_id_no": market.token_id_no,
                "midpoint_yes": midpoint,
            }
        except Exception as e:
            summary[market.name] = {"error": str(e)}
    return summary
